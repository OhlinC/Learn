# 测试中的断言

XUnit 是一个流行的单元测试框架，其提供了多种断言方法用于编写测试。XUnit 2.x 版本包

**<u>`Substitute.For<>`</u>**

[Substitute]([NSubstitute: Getting started](https://nsubstitute.github.io/help/getting-started/))：模拟框架，用于代理接口

行为定义

todo:

1. public interface ICalculator   
   
   ---

2. {   
   
   ---

3. int Add(int a, int b);   
   
   ---

4. string Mode { get; set; }   
   
   ---

5. event EventHandler PoweringUp;   
   
   ---



1. calculator = Substitute.For<ICalculator>();

2. calculator.Add(1, 2).Returns(3);   
   
   ---

3. Assert.That(calculator.Add(1, 2), Is.EqualTo(3));



在某些情况下（特别是对于`void`方法），检查替代者是否已收到特定调用很有用。这可以使用`Received()`扩展方法进行检查，然后检查调用。

```csharp
public interface ICommand {
    void Execute();
    event EventHandler Executed;
}

public class SomethingThatNeedsACommand {
    ICommand command;
    public SomethingThatNeedsACommand(ICommand command) { 
        this.command = command;
    }
    public void DoSomething() { command.Execute(); }
    public void DontDoAnything() { }
}

[Fact]
public void Should_execute_command() {
    //Arrange
    var command = Substitute.For<ICommand>();
    var something = new SomethingThatNeedsACommand(command);
    //Act
    something.DoSomething();
    //Assert
    command.Received().Execute();
}
```

NSubstitute 还可以确保未使用`DidNotReceive()`扩展方法接收到呼叫。

```csharp
var command = Substitute.For<ICommand>();
var something = new SomethingThatNeedsACommand(command);
//Act
something.DontDoAnything();
//Assert
command.DidNotReceive().Execute();
```

扩展`Received()`方法将断言至少对成员进行了一次调用，并`DidNotReceive()`断言进行了零次调用。NSubstitute 还让您可以选择通过将整数传递给 来断言收到了特定数量的呼叫`Received()`。如果替代者没有收到那么多匹配的调用，这将*抛出*。太少或太多，断言都会失败。

```csharp
public class CommandRepeater {
    ICommand command;
    int numberOfTimesToCall;
    public CommandRepeater(ICommand command, int numberOfTimesToCall) {
      this.command = command;
      this.numberOfTimesToCall = numberOfTimesToCall;
    }

    public void Execute() { 
      for (var i=0; i<numberOfTimesToCall; i++) command.Execute();
    }
}

[Fact]
public void Should_execute_command_the_number_of_times_specified() {
  var command = Substitute.For<ICommand>();
  var repeater = new CommandRepeater(command, 3);
  //Act
  repeater.Execute();
  //Assert
  command.Received(3).Execute(); // << This will fail if 2 or 4 calls were received
}
```

含以下断言方法：

1. `Assert.Equal()`: 断言两个值相等。
2. `Assert.NotEqual()`: 断言两个值不相等。
3. `Assert.True()`: 断言表达式为 true。
4. `Assert.False()`: 断言表达式为 false。
5. `Assert.Null()`: 断言值为 null。
6. `Assert.NotNull()`: 断言值不为 null。
7. `Assert.Same()`: 断言两个对象是同一个对象。
8. `Assert.NotSame()`: 断言两个对象不是同一个对象。
9. `Assert.Contains()`: 断言集合中包含某个元素。
10. `Assert.DoesNotContain()`: 断言集合中不包含某个元素。
11. `Assert.Empty()`: 断言集合为空。
12. `Assert.NotEmpty()`: 断言集合不为空。
13. `Assert.StartsWith()`: 断言字符串以指定字符或字符串开头。
14. `Assert.EndsWith()`: 断言字符串以指定字符或字符串结尾。
15. `Assert.InRange()`: 断言值在指定范围内。
16. `Assert.Throws()`: 断言代码块会抛出指定异常。
17. `Assert.ThrowsAny()`: 断言代码块会抛出任何异常。

除了这些方法外，还有一些定制的断言方法可以通过创建自定义断言类来实现。

Shouldly 是一个基于 Fluent 风格的 .NET 断言库，它提供了多种简洁易读的断言方法。下面是 Shouldly 中常用的几种断言方法：

1. `ShouldBe`：判断两个对象是否相等，并在对象不相等时输出详细的错误信息。
2. `ShouldNotBe`：判断两个对象是否不相等，并在对象相等时输出详细的错误信息。
3. `ShouldBeNull`：判断对象是否为 null，并在对象不为 null 时输出详细的错误信息。
4. `ShouldNotBeNull`：判断对象是否不为 null，并在对象为 null 时输出详细的错误信息。
5. `ShouldBeTrue`：判断表达式是否为 true，并在表达式为 false 时输出详细的错误信息。
6. `ShouldBeFalse`：判断表达式是否为 false，并在表达式为 true 时输出详细的错误信息。
7. `ShouldContain`：判断集合中是否包含指定元素，并在不包含指定元素时输出详细的错误信息。
8. `ShouldNotContain`：判断集合中是否不包含指定元素，并在包含指定元素时输出详细的错误信息。
9. `ShouldBeInRange`：判断数值是否在指定范围内，并在数值不在指定范围内时输出详细的错误信息。
10. `ShouldThrow`：判断代码块是否抛出指定异常，并在代码块未抛出指定异常时输出详细的错误信息。

除了上述方法外，Shouldly 还提供了许多其他实用的断言方法，如 `ShouldBeAssignableTo`、`ShouldBeSameAs`、`ShouldNotBeSameAs` 等等。
